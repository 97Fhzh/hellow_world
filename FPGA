www.edacn.com
www.chnxp.com.cn 免费电子书 
数字信号处理的FPGA实现(PDF版)2版.pdf 刘凌 胡永生 清华大学出版社

电子系统设计的描述等级
1、行为级
2、RTL级（Register transfer level）
3、逻辑门级
4、版图级
用VHDL可以描述以上四个等级

Entity(实体）
Architecture 1（构造体）
process(进程结构） subprograms(子程序） block(块结构）
                 procedure（过程）   function(函数）

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
entity count is
    port (  clock,reset: in STD_LOGIC;
            dataout: out STD_LOGIC_VECTOR (3 downto 0)   );
end count;
architecture behaviorl of count is
  signal databuffer:  STD_LOGIC_VECTOR (3 downto 0);
 begin
  dataout<=databuffer; 
   process(clock,reset)
    begin
      if (reset='1') then      databuffer<="0000";
       elsif (clock'event and clock='1') then  
         if databuffer="1000"   then
          databuffer<="0000";   else    databuffer<=databuffer+'1';
        end if;
      end if;
   end process;        
 end  behavioral;

VHDL结构要点
ENTITY（实体）
格式： 
      Entity  实体名  IS
               [类属参数说明]
               [端口说明]
      End Entity；  
  其中端口说明格式为：
  PORT(端口名1，端口名N：方向：类型）
  其中方向有: IN , OUT, INOUT, BUFFER, LINKAGE

In 信号只能被引用,不能被赋值
out 信号只能被赋值,不能被引用
buffer 信号可以被引用,也可以被赋值

In  不可以出现在<= 或  : = 的左边
out不可以出现在<= 或  : = 的右边
buffer可以出现在<= 或  : = 的两边

(HalfAdd) (FullAdd)

Arcthitecture 构造体名 of  实体名  is 
       [定义语句] 内部信号、常数、元件、数据类型、函数等的定义
     begin 
       [并行处理语句和block、process、function、procedure]
     end 构造体名；
     
除了entity(实体)和architecture(构造体)外还有
另外三个可以独立进行编译的设计单元

Package（包集合）属于库结构的一个层次，存放信号定义、常数定义、数据类型、元件语句、函数定义和过程定义。
Package Body 具有独立对端口(port)的package
configuration（配置）描述层与层之间的连接关系以及实体与构造体之间关系。

库： 数据的集合。内含各类包定义、实体、构造体等
STD库    --VHDL的标准库
IEEE库   -- VHDL的标准库的扩展
面向ASIC的库 --不同的工艺
不同公司自定义的库
普通用户自己的库

用户自己的库
    当您的VHDL文件被编译后，编译的结果储存在特定的目录下，这个目录的逻辑名称即Library，此目录下的内容亦即是这个Library的内容。

对象object
    对客观实体的抽象和概括
VHDL中的对象有：
1、Constant（常量）在程序中不可以被赋值 
2、Variable（变量）在程序中可以被赋值(用“: =”)，赋值后立即变化为新值。 
3、Signal（信号）在程序中可以被赋值(用“<=”) ，但不立即更新，当进程挂起后，才开始更新。

VHDL中的对象使用：
 variable  
     x，y：integer；--定义了整数型的变量对象x，y
    
 constant  
     Vcc：real；--定义了实数型的常量对象Vcc

  signal 
    clk，reset：bit；--定义了位类型的信号对象clk，reset

variable只能定义在process和subprogram（包括function和procedure）中，不可定以在其外部。
2、signal不能定义在process和subprogram（包括function和procedure）中，只可定以在其外部。

对象的属性
   类似于其它面向对象的编程语言如VB、VC、DELPHI
     用法格式：对象 ’ 属性       
     例       子：clk’event      --表明信号clk的event属性
 常用的属性：
  Signal 对象的常用属性有：
   event ： 返回boolean值，信号发生变化时返回true
   last_value：返回信号发生此次变化前的值
   last_event：返回上一次信号发生变化到现在变化的间隔时间

Signal 对象的常用属性有：接上页

delayed[(时延值)]: 使信号产生固定时间的延时并返回
stable[(时延值)]: 返回boolean, 信号在规定时间内没有变化返回true
transaction: 返回bit类型，信号每发生一次变化，返回值翻转一次
A<=B’delayed(10 ns)；    --B延时10ns后赋给A；
           if（B’Stable(10 ns)）；    --判断B在10ns中是否发生变化
           
信号的event和last_value属性经常用来确定信号的边沿          
判断clk的上升沿
if （ (clk’event)and (clk=‘1’) and(clk’last_value=‘0’)） then
判断clk的下降沿
if （ (clk’event)and (clk=‘0’) and(clk’last_value=‘1’)） then

bit(位)： `0` 和`1`
2、bit-Vector(位矢量)： 例如：``00110``
3、Boolean “ ture”和“false”
4、time  例如：1 us、100 ms，3 s
5、character 例如：‘a’、’n’、’1’、 ’0’
6、string  例如：“sdfsd”、”my design”
7、integer  32位例如：1、234、-2134234
8、real 范围-1.0E38~+1.0E38 
             例如：1.0、2.834、3.14、0.0

natural  自然数 和 positive 正整数
10、senverity level  （常和assert语句配合使用）
       包含有：note、warning、error、failure
   
以上十种类型是VHDL中的标准类型，在编程中可以直接使用。使用这十种以外的类型，需要自行定义或指明所引用的Library(库)和Package(包)集合

例子中信号Z有两个驱动A和B；Z必须定义为一种新的数据类型，否则Z将无法决定取值，语句视为非法。
通用格式
   TYPE 类型名  IS  数据类型定义 
用户可以定义的数据类型
枚举类型enumberated、整数型integer、
实数型real、数组类型array、
纪录类型record、时间类型time、
文件类型file、存取类型access

枚举类型enumberated
格式
  type 数据类型名 is （元素，元素…...）;
例子
  type week is (sun,mon,tue,thu,fri,sat);
  type std_logic is (‘1’,’0’,’x’,’z’);
整数类integer和实数类real
格式
  type 数据类型名 is 数据类型定义  约束范围;
例子
  type  week is   integer range 1 to 7;
  type  current is   real   range -1E4 to 1E4 
引用时间时，有的编译器要求量 与单位 之间应有一个空格如：1 ns；不能写为1ns；
纪录类型record
格式
  type 数据类型名 is  recoerd 
    元素名:数据类型名;
    元素名:数据类型名;
     ….
  end record;
   1、VHDL属于强类型，不同类型之间不能进行运算和赋值，可以进行数据类型转换
   2、vector不表示number
   3、array 不表示number
通过本讲您将会学到
1、Block的编写
2、Process的编写
3、function 和 procedure的编写
4、VHDL中的流程控制语句的书写
Architecture 中的语句及子模块之间是并行处理的
子模块block中的语句是并行处理的
子模块process中的语句是顺序处理的
子模块subprogram中的function和procedure是顺序处理的

Arcthitecture 构造体名 of  实体名  is 
      [定义语句] 内部信号、常数、元件、数据类型、函数等的定义
     begin 
      [并行处理语句和block、process、function、procedure]
     end 构造体名；
 BLOCK  [（布尔表达式）] 
      [定义语句]
       begin
         [并行处理语句concurrent statement
         [信号]<= guarded   [信号,延时] ;
     end block  块名
[进程名：]  
   process  [（触发信号列表）]
     [定义语句；]
   begin
     [串行处理语句sequential statement；]
   end process
Process中敏感信号列表的普遍原则是：
    在process中，其值被引用的信号应当出现在敏感信号列表中
二选一的选择器：A、B为输入信号；SEL为选路信号；Z为输出信号；
wait；--无限等待
       wait on [信号列表]    --等待信号变化
       wait until [条件]；    --等待条件满足
       wait for [时间值]；   --等待时间到 
如果process中没有敏感信号列表，其进程中也没
有wait 语句，则process中的程序代码循环执行
process
     begin
      clk<=not clk after 50 ns ;
end process
Assert语句格式
信号赋值操作
2、带条件的信号赋值语句
3、带选择的信号赋值语句

Block                                                             
begin
 with  sel select    
   q<=ain  when sel=“00”， 
          bin when sel=“01”，
          cin  when sel=“10”，
          din when sel=‘11”
          xx; when others；                                                                   
end block    
顺序执行语句和并行处理语句总结
1、顺序执行语句 wait、assert、if -else 、case、for-loop、while语句只能用在process、function 和 procedure 中；
2、并行处理语句（条件信号带入和选择信号带入）只能用在architecture、block中；
状态机的设计
一类十分重要的时序电路
许多数字电路的核心部件
状态机的结构：
      A、组合逻辑部分（状态译码器和输出译码器）
      B、寄存器部分
各部分的功能
   1、状态译码器
         确定状态机的下一个状态
   2、输出译码器
         确定状态机输出
   3、状态寄存器
         存储状态机的内部状态
状态的转换
      下一个状态由译码器根据当前状态和输入条件决定。
2、输出信号的产生
       输出信号由译码器根据当前状态和输入条件决定
同步时序状态机
    由时钟信号触发状态的转换和信号的输出
异步时序状态机
    状态的转移和输出不与时钟信号同步
两种类型
1、米里（mealy）状态机---使用输入信号

2、莫尔（moore）状态机---不使用输入信号

编译和仿真工具 
   OR-CAD或ACTIVE-VHDL
本次培训采用ACTIVE-VHDL
ACTIVE-VHDL自带教程
    目录: ..\Active VHDL\book\Avhdl.htm


原型验证过程中的ASIC到FPGA的代码转换2007-10-24 02:40在对ASIC设计进行FPGA原型验证时，由于物理结构不同，ASIC的代码必须进行一定的转换后才能作为FPGA的输入

现代集成电路设计中，芯片的规模和复杂度正呈指数增加。尤其在ASIC设计流程中，验证和调试所花的时间约占总工期的70%。为了缩短验证周期,在传统的仿真验证的基础上，涌现了许多新的验证手段，如断言验证、覆盖率驱动的验证，以及广泛应用的基于现场可编程器件(FPGA)的原型验证技术。

采用FPGA原型技术验证ASIC设计，首先需要把ASIC设计转化为FPGA设计。但ASIC是基于标准单元库，FPGA则是基于查找表，ASIC和FPGA物理结构上的不同，决定了ASIC代码需要一定的修改才能移植到FPGA上。但应该注意到这只是由于物理结构不同而对代码进行的转换，并不改变其功能，因此对代码的这种修改只能限制在一定范围内。

基本原理

基于FPGA原型验证的流程

由于FPGA的可编程特性，基于FPGA的原型技术已经被广泛采用。和仿真软件相比，FPGA的硬件特性可以让设计运行在较高的频率上，加速仿真。另一方面，可以在ASIC芯片设计前期并行设计外围电路及应用软件，缩短了芯片验证周期。

FPGA原型验证和其他验证方法是不同的，任何一种其他验证方法都是ASIC验证中的一个环节，而FPGA验证却是一个过程。由于FPGA与ASIC在结构、性能上各不相同，ASIC是基于标准单元库，FPGA用的是厂商提供的宏单元模块，因此首先要进行寄存器传输级(RTL)代码的修改。然后进行FPGA器件映射，映射工具根据设置的约束条件对RTL代码进行逻辑优化，并针对选定的FPGA器件的基本单元映射生成网表。接着进行布局布线，生成配置文件和时序报告等信息。当时序能满足约束条件时，就可以利用配置文件进行下载。如果时序不能满足约束，可通过软件报告时序文件来确认关键路径，进行时序优化。可以通过修改约束条件，或者修改RTL代码来满足要求。

需要转换的代码

存储单元

存储单元是必须进行代码转换的，ASIC中的存储单元通常用代工厂所提供的Memory Compiler来定制，它可以生成.gsp、.v等文件。.v文件只用来做功能仿真，通常不能综合。而最后流片时，只需将标准提供给代工厂。如果直接将ASIC代码中的存储单元作为FPGA的输入，通常综合器是综合不出来的，即使能综合出来，也要花费很长时间，并且资源消耗多、性能不好。而FPGA厂商其实已经提供了经过验证并优化的存储单元。因此存储单元要进行代码转换。

时钟单元

数字电路中，时钟是整个电路最重要、最特殊的信号。在ASIC中，用布局布线工具来放置时钟树，利用代工厂提供的PLL进行时钟设计。FPGA中通常已经配置一定数量的PLL宏单元，并有针对时钟优化的全局时钟网络，一般是经过FPGA的特定全局时钟管脚进入FPGA内部，后经过全局时钟BUF适配到全局时钟网络的，这样的时钟网络可以保证相同的时钟沿到达芯片内部每一个触发器的延迟时间差异是可以忽略不计的。因此时钟单元也是需要进行转换的。

增加流水

由于实现结构上的不同，FPGA器件内部的单元延时远大于ASIC的基本门单元延时。导致在同样设计的情况下，ASIC可以满足其时序，而FPGA有可能无法满足。为了验证的需要，修改ASIC代码实现FPGA原型时，对ASIC实现的流水结构在FPGA实现时需要适当增加流水。比如在一个很长的组合逻辑路径中加入寄存器。如图1所示。


图1 增加流水

同步设计

在FPGA设计中，同步设计是应该遵循的重要原则。异步设计容易导致电路处于亚稳态，产生毛刺。当从ASIC设计转向FPGA设计时，应该进行仔细的同步。具体体现在主时钟选取、功能模块的统一复位、同步时序电路设计。

在FPGA设计中要使用时钟使能代替门控时钟。在ASIC的设计中，为了减少功耗，使用门控时钟(clock gating)，门控时钟的结构如图2所示。当写有效时，数据才写进存储器，那么只有写有效时，寄存器才会发生翻转，这样可以减少功耗。


图2 门控时钟示意图

由于设计的异步特性，对于FPGA来说，使用这种门控时钟容易产生毛刺，导致数据不正确。所以在FPGA设计中，使用有使能信号的电路来替换门控时钟电路。可以在寄存器前面加上MUX来实现时钟使能信号，如图3所示。现在的FPGA厂商则提供可以直接有使能，同步SET和RESET引脚的寄存器，如图4所示。


图3 用MUX生成时钟使能信号



图4 FPGA内带有时钟使能的寄存器

充分利用FPGA中已有的IP核

FPGA厂商及第三方厂商已经实现并优化了很多典型的IP核，例如Xilinx提供了基础逻辑、总线接口与I/O、视频与图像处理、数字信号处理、存储器接口、微处理器、控制器等大量IP核。在代码转换时可以充分利用这些资源，对代码进行优化来提高设计性能。如在FPGA中使用SRL实现移位寄存器，用三态Buffer来替换三态总线和三态MUX，改进算术单元和有限状态机的编码。 
代码转换的实现

结合同济大学微电子中心的“32位高性能嵌入式CPU开发”项目，为了在流片之前确保功能的可靠性，对32位全定制高性能嵌入式CPU bc320进行了原型验证。

设计采用Memec Design公司的FF1152开发板。该板使用了Xilinx的Virtex-Ⅱ Pro系列芯片中的XC2VP30。该FPGA拥有30 816个逻辑单元，相当于有30多万的ASCI门。另有2Mb的片上Block RAM，644个I/O口。采用了Xilinx的全自动、完整的集成设计环境ISE 7.1i，进行FPGA综合使用的工具是Synplify Pro。

用bc320的ASIC RTL代码作为FPGA的输入，具体的代码转换如下。

存储单元

设计中用到了很多SRAM，例如Icache中的SRAM。在FPGA实现时根据所需RAM的宽度、深度和功能来决定采用哪种单元来进行替换。Xilinx提供了片外RAM、Block RAM和LUT RAM。

ISE提供了两种具体的实现方法：IP生成器(Core Generator)和语言模板(Language Templates)。IP生成器是Xilinx FPGA设计中的一个重要设计输入工具，它提供了大量Xilinx和第三方公司设计的成熟高效IP核。

这里是用Core Generator来产生了名为块存储器(Block Memory)的单口存储器模块。Core Generator用图形化设置参数的方式来提供块存储器，其界面如图5所示。块存储器的大小根据向量的大小来制定，一个普通单元向量只需要4个512×32bit的块存储器就够了。Core Generator产生块存储器时，除了参数设置外，还需要输入一个为.coe的文件来初始化块存储器的内容。Core Generator产生的文件同时考虑了后端执行和仿真两方面，主要有三个文件：file.v，file.mif，file.edn。其中.v文件为Verilog格式的SRAM仿真模型； .mif文件为作为其初始化内容，其内容和.coe文件里的具体向量内容是一致的；而实际后端文件为.edn，包含了块存储器的全部信息。


图5 IP生成器的界面

Language Templates主要利用Xilinx的块存储器元件库，直接进行调用。XC2VP30内部的单口块存储器型号主要有：16k×1bit、1k×16bit、2k×8bit、4k×4bit、512×32bit、8k×2bit。可以根据自己的需要随意调用这些模块，在RTL代码中实例化，并把SRAM初始值作为参数传递进去。这些模块在Synplify Pro中根据选定的FPGA型号被自动识别，然后综合成统一的.edn文件，再进行后续操作。语言模板方式的灵活性比较强，可以设置多个不同位宽，不同深度的块存储器，仿真也比较方便，但是参数设定时，SRAM初始值的设置比较麻烦。

另外，Xilinx提供工具Data2mem，它可以每次只改变FPGA中块存储器的内容，而不需将整个设计重新翻译、映射和布局布线，为大量的向量验证节约了时间。

时钟单元

在bc320设计中，CPU内核通过SYSAD接口与外部SRAM连接。这些外部SRAM的时钟和主时钟是不一致的，在ASIC中，用一个PLL来实现。这个PLL模块是无法用Synplify Pro综合的，在FPGA上必须将它用Xilinx的数字时钟管理模块(DCM)来替换。同样可以利用Core Generator和Language Templates这两种方法。

利用Core Generator产生mydcm.v文件来代替原先的PLLGS_500.v，代码如下。第二段代码是修改后的代码。

module PLLGS_500( PLL_K,
PLL_M,
PLL_N,
PLL_PD,
PLL_TST,
RESET,
XIN,
CLK_OUT,
TST_OUT);

module mydcm(CLKIN_IN, 
RST_IN,
CLKFX_OUT,
CLKIN_IBUFG_OUT,
LOCKED_OUT);

时钟使能带代替门控时钟

把实现门控时钟信号转换成实现使能信号，例如信号PCEPL，代码如下。第二段代码是修改后的代码。

module(out,in,CLK, PCEPL);
……
always @ (CLK or PCEPL)
assign PCEPLV     = PCEPL & CLK;
always @(posedge PCEPLV)
begin
out <= in;
end
endmodule

module(out,in,CLK, PCEPL);
……
always @(posedge CLK)
begin
if (PCEPL)
out <= in;
else
out <= out;
end
endmodule

外部器件配置单元和顶层封装

在FF1152开发板上集成了很多接口和器件，在原型验证时，可以充分利用这些接口和器件做为和设计的交互环境。这些接口和器件需要正确配置后才能正常工作，这部分配置工作可以用FPGA实现。

设计增加了LCD接口单元、内部记分牌(scoreboard)模块和通用异步串行接收发送(UART)模块。作为保存向量内容的SRAM设定好后，可以用同样的方法将寄存器参考值也保存在另外的块存储器中。然后运行CPU，将CPU实际产生的寄存器值和已保存过的参考值在记分牌模块中进行实时比较，然后将结果输出到LCD显示屏上。

为了便于代码的管理和维护，可以对原RTL代码进行一定的封装。将原ASIC流程的代码单独封装在一个模块中，再和FPGA实现时添加的片外配置控制单元的代码一起形成新的FPGA实现顶层。

所以在ASIC代码的基础上增加了对这几个器件完成配置工作的代码部分。

为了原型系统获得更高的性能，还可以对其他一些模块的代码进行适当的改进，如算术单元和状态机的编码风格等。但对于全定制的cpu bc320，没有必要修改算术单元模块的代码，关键是存储模块和时钟单元。因此要根据自己的设计适当选择要修改的代码 
 
