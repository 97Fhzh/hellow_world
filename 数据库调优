SQL调优

可以从以下方面衡量查询计划和时间复杂性，并进一步调优SQL查询：

·         用索引扫描替换不必要的大数据表的全表扫描;

·         确保表的连接顺序为最佳顺序;

·         确保以最佳方式使用索引;

·         将小数据表的全表扫描缓存起来。

《如何编写更好的SQL查询》教程的所有内容就介绍到这里，希望通过本教程的介绍，能够帮助大家编写出更好、更优的SQL查询。

原文链接：https://www.datacamp.com/community/tutorials/sql-tutorial-query#importance



相关阅读：


Kinetica gpu 关系数据库服务提供商 与美国机构关系紧密
服务器浮动IP
单点写入，负债均衡，

CPU过载–- 慢查询，OPTIMZE TABLE
内存使用问题–- 内存相关参数配置不合理
磁盘I/O -- Buffer pool命中率；慢查询；redo, undo, data分开存放
网络问题– 非专有网络，网络路由
表及查询语句问题


由 wm_conca t引发了性能问题

显然，从 SQL 功能上，wm_concat 是必须的，我也尝试过用 listagg 来替代 wm_concat，但是会因超过 4000 字符而报错。

其实 wm_concat 函数之所以慢，就是因为以 task_name 为维度需要拼凑的数据量太大导致的。难道就无解了吗?

我转念一想，为什么要用 wm_concat 函数?应用程序在拿到这个字段后做什么用呢?在前端页面显示吗?

这种显示是没有多大意义的，因为 wm_concat 的结果可能非常大，根本就显示不了。既然显示不完整，那么为什么又要从 DB 中获取完整的内容呢?

带着这些疑惑，我与 SQL 开发人员进行了沟通，原来，应用程序拿到这个 SQL 的数据后，并不是在前端页面展现，而是在应用程序中继续加工处理，在经过若干复杂的逻辑处理后，以另一种形式在页面展现。

此时，多年的从业经验告诉我：既然可以用 Java 来实现的业务逻辑，那么肯定也能在 DB 中通过 SQL 来实现，这样就可以避开 wm_concat 函数。

于是我决心深入了解业务功能，希望能从业务方案上有所突破。这样就形成了一个初步的工作计划：了解整体业务功能及逻辑-->了解应用程序处理逻辑-->改写 SQL 语句-->功能性测试-->性能轮回调整。

在大约两个小时的一对一讲解后，我基本上掌握了整体业务功能及逻辑、应用技术架构及处理逻辑。

这个其实是一个报表展现功能，是按区域、里程碑展现两个相邻里程碑之间的时间间隔，包括计划间隔时间与实际间隔天数(平均)。

在一个行列转换的问题，即将 TASK_NAME 从以行存储转换成以列展现。

为了实现这种结构转换，当时的架构设计如下：

·         通过 SQL 从 DB 获取每个里程碑、交付区域的 plan_start_time、plan_end_time、actural_start_time、actural_end_time 及 du 集合，即 SQL 中的 wm_concat 拼凑后的结果。

·         Java 应用程序拿到这个结果后，循环结果集，并依次分解由 wm_concat 拼凑的内容：计算每一个里程碑内 DU 的平均时间间隔;判断里程碑的前后置关系;计算前后置里程碑间的天数间隔;最终将计算结果展现在前端页面。

04.水到渠成，一战而定

从上述描述中，我们可以提炼出如下信息：

·         WM_CONCAT 拼凑的内容只是过渡的，在 Java 中还需要依次分解。

·         Java 处理的几个步骤完全可以由 SQL 来实现。

这样就可以省却以下几个“麻烦”：

·         省却了大量数据从 DB 传输到 Java 服务器的成本开销。

·         可以顺理成章的拔掉 wm_concat 这根刺。

那么，如果用 SQL 来实现上述逻辑功能，存在两个难点，其一是如何判断里程碑(task_name)前后置关系，其二是计算前后置里程碑的时间差。

进一步分析后发现，里程碑(task_name)前后置关系可以通过 SQL 来获取，而在时间间隔的计算上，可以通过 lead 窗口分析函数获取后置时间，然后相减即可。

值得一提的是，这个 SQL 并非一蹴而就的，从第一次改写，到最终上线，经历了好几个版本，但整体结构并没有变动，只是对某些特殊场景做了调整。

我来项目的第一个 SQL 优化就这样跌跌撞撞、歪打正着的完成了。由于时间紧迫，整个过程都是绷紧了神经。

现在回想起来，既是庆幸又是后怕，庆幸的是问题得到了及时解决;后怕的是，当时可谓是不知者无畏，完全是在不熟悉环境，不熟悉利害关系的情况下解决了问题。如果放在几个月后，我想一定没有当时的勇气和决心来完成这件事情。

回过头来看，这起由 wm_concat 引发的性能事件还是给了我们很多的启发：

SQL 优化不是孤立的存在

SQL 优化并不是孤立的，也就是说并不是所有的 SQL 本身都存在优化的空间。当 SQL 本身无法优化的时候，或者优化的空间不足以满足用户需求时，就需要从全局需求突破。

尝试着按另一种方式得到结果：殊途同归讲的不就是这个道理吗?正所谓山重水复疑无路，柳暗花明又一村，关键在于你是否愿意主动寻求和突破。

SQL 优化其实很朴素

SQL 优化并不需要多么高深的知识和高级的技术，SQL 优化也并不那么神秘，一点点技术，一点点经验，再加上一点点运气就足够了。

一点点技术

这里说的技术是 SQL 技术。SQL 语言我认为是除汇编外所有语言中最神奇、最简单、最具艺术化的语言。

说简单，就 select 查询而言，就 select from where and or group order 等屈指可数的几个关键字，拿 SQL 而言也就 select、update、delete、insert 四种功能。而且通俗易懂。

说神奇，因为就这些关键字，无需排列组合，便可以千变万化。在当今的信息化大时代，无外乎就是增删改查;大千世界，芸芸众生，概莫能外。

就拿人类自身来说，其终极哲学就是：生老病死，出生就是 insert，岁月催人老就是 update，众里寻他千百度就是 select，荣登极乐就是 delete。

说艺术化，简单而不简约，这就是艺术，能以数个关键字撑起世间万物的起起落落，这就是艺术。

这里说的掌握 SQL 技术，不仅仅是掌握这几个关键字，用这几个关键字变幻出种种结果，更是要掌握如何通过这几个关键字来实现这种艺术化的效果。

